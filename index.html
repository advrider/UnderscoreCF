<!DOCTYPE html>
<!-- saved from url=(0070)http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#result -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>UnderscoreCF</title>
	
	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<meta name="viewport" content="width=device-width">
	<link rel="stylesheet" type="text/css" href="./index_files/style.css">
</head>
<body>
	<div id="sidebar" class="interface">
		<a class="toc_title" href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#">
		    UnderscoreCF <span class="version">(.01)</span>
	    </a>
	    <a class="toc_title" href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#">
	    	Introduction
	    </a>
    	
		    <a class="toc_title" href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#Collections">
			    Collections
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#each">each</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#map">map</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#reduce">reduce</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#find">find</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#filter">filter</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#reject">reject</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#all">all</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#any">any</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#include">include</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#pluck">pluck</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#max">max</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#min">min</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#sortBy">sortBy</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#groupBy">groupBy</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#sortedIndex">sortedIndex</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#shuffle">shuffle</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#toArray">toArray</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#size">size</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#Arrays">
			    Arrays
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#first">first</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#initial">initial</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#last">last</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#rest">rest</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#compact">compact</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#flatten">flatten</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#without">without</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#union">union</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#intersection">intersection</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#difference">difference</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#uniq">uniq</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#zip">zip</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#indexOf">indexOf</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#lastIndexOf">lastIndexOf</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#range">range</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#Functions">
			    Functions
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#bind">bind</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#bindAll">bindAll</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#memoize">memoize</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#delay">delay</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#once">once</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#after">after</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#wrap">wrap</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#Objects">
			    Objects
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#keys">keys</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#values">values</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#functions">functions</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#extend">extend</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#pick">pick</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#defaults">defaults</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#clone">clone</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#has">has</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isEmpty">isEmpty</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isArray">isArray</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isObject">isObject</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isFunction">isFunction</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isString">isString</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isNumber">isNumber</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isBoolean">isBoolean</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isDate">isDate</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#isNaN">isNaN</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#Utilities">
			    Utilities
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#times">times</a></li><li>- <a href="http://localhost:8500/github/UnderscoreCF/docs/docGenerator.cfm#mixin">mixin</a></li><li>- <a href="./index_files/index.html">result</a></li>			    	
		    </ul>
    	
	</div>
	<div class="container">
		<h1>Underscore.cfc</h1>
		<p id="Introduction">
			Underscore.cfc is a port of <a href="http://underscore.js/">Underscore.js</a> for Coldfusion. It is a utility-belt library that provides a lot of the functional programming support that you would expect in Prototype.js (or Ruby). <br><br>Underscore provides dozens of functions that support both the usual functional suspects: map, select, invoke - as well as more specialized helpers: function binding, <s>templating, deep equality testing,</s> and so on. It delegates to built-in functions where applicable.<br><br>UnderscoreCF is currently only tested on Adobe Coldfusion 10. <b>It is still in progress, so please be extra-careful using it.</b><br><br>Some unit tests are included, but much work needs to be done there.<br><br>The project is <a href="http://github.com/russplaysguitar/underscorecf">hosted on GitHub</a>. Contributions are welcome.
		</p>
		<h2 id="Collections">Collection Functions (Arrays or Objects)</h2>
		<p id="each"><b class="header">each</b> <code>_.each(list, iterator, [context])</code><br>Iterates over a list of elements, yielding each in turn to an iterator function. The iterator is bound to the context object, if one is passed. Each invocation of iterator is called with three arguments: (element, index, list). If list is an object, iterator's arguments will be (value, key, list).<br></p><pre>_.each([1, 2, 3], function(num){ writeDump(num); }); <br>=&gt; dumps each number in turn... <br>_.each({one : 1, two : 2, three : 3}, function(num, key){ writeDump(num); });<br>=&gt; dumps each number in turn...</pre><p></p><p id="map"><b class="header">map</b> <code>_.map(list, iterator, [context])</code><br>Produces a new array of values by mapping each value in list through a transformation function (iterator). If list is an object, iterator's arguments will be (value, key, list).<br></p><pre>_.map([1, 2, 3], function(num){ return num * 3; }); <br>=&gt; [3, 6, 9] <br>_.map({one : 1, two : 2, three : 3}, function(num, key){ return num * 3; });<br>=&gt; [3, 6, 9]</pre><p></p><p id="reduce"><b class="header">reduce</b> <code>_.reduce(list, iterator, memo, [context])</code><br>Also known as inject and foldl, reduce boils down a list of values into a single value. Memo is the initial state of the reduction, and each successive step of it should be returned by iterator.<br></p><pre>sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);<br>=&gt; 6</pre><p></p><p id="find"><b class="header">find</b> <code>_.find(list, iterator, [context])</code><br>Looks through each value in the list, returning the first one that passes a truth test (iterator). The function returns as soon as it finds an acceptable element, and doesn't traverse the entire list.<br></p><pre>even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; 2</pre><p></p><p id="filter"><b class="header">filter</b> <code>_.filter(list, iterator, [context])</code><br>Looks through each value in the list, returning an array of all the values that pass a truth test (iterator).<br></p><pre>evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; [2, 4, 6]</pre><p></p><p id="reject"><b class="header">reject</b> <code>_.reject(list, iterator, [context])</code><br>Returns the values in list without the elements that the truth test (iterator) passes. The opposite of filter.<br></p><pre>odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; [1, 3, 5]</pre><p></p><p id="all"><b class="header">all</b> <code>_.all(list, iterator, [context])</code><br>Returns true if all of the values in the list pass the iterator truth test.<br></p><pre>_.all([true, 1, 'yes'], _.identity);<br>=&gt; false</pre><p></p><p id="any"><b class="header">any</b> <code>_.any(list, [iterator], [context])</code><br>Returns true if any of the values in the list pass the iterator truth test. Short-circuits and stops traversing the list if a true element is found.<br></p><pre>_.any([0, 'yes', false]);<br>=&gt; true</pre><p></p><p id="include"><b class="header">include</b> <code>_.include(list, value)</code><br>Returns true if the value is present in the list.<br></p><pre>_.include([1, 2, 3], 3);<br>=&gt; true</pre><p></p><p id="pluck"><b class="header">pluck</b> <code>_.pluck(list, propertyName)</code><br>A convenient version of what is perhaps the most common use-case for map: extracting a list of property values.<br></p><pre>stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];<br>_.pluck(stooges, 'name');<br>=&gt; ["moe", "larry", "curly"]</pre><p></p><p id="max"><b class="header">max</b> <code>_.max(list, [iterator], [context])</code><br>Returns the maximum value in list. If iterator is passed, it will be used on each value to generate the criterion by which the value is ranked.<br></p><pre>stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];<br>_.max(stooges, function(stooge){ return stooge.age; });<br>=&gt; {name : 'curly', age : 60};</pre><p></p><p id="min"><b class="header">min</b> <code>_.min(list, [iterator], [context])</code><br>Returns the minimum value in list. If iterator is passed, it will be used on each value to generate the criterion by which the value is ranked.<br></p><pre>numbers = [10, 5, 100, 2, 1000];<br>_.min(numbers);<br>=&gt; 2</pre><p></p><p id="sortBy"><b class="header">sortBy</b> <code>_.sortBy(list, iterator, [context])</code><br>Returns a sorted copy of list, ranked in ascending order by the results of running each value through iterator. Iterator may also be the string name of the property to sort by (eg. length).<br></p><pre>_.sortBy([1, 2, 3, 4, 5, 6], function(num){ return Math.sin(num); });<br>=&gt; [5, 4, 6, 3, 1, 2]</pre><p></p><p id="groupBy"><b class="header">groupBy</b> <code>_.groupBy(list, iterator)</code><br>Splits a collection into sets, grouped by the result of running each value through iterator. If iterator is a string instead of a function, groups by the property named by iterator on each of the values.<br></p><pre>_.groupBy([1.3, 2.1, 2.4], function(num){ return fix(num); });<br>=&gt; {1: [1.3], 2: [2.1, 2.4]}<br><br>_.groupBy(['one', 'two', 'three'], function(num) { return len(num); });<br>=&gt; {3: ["one", "two"], 5: ["three"]}</pre><p></p><p id="sortedIndex"><b class="header">sortedIndex</b> <code>_.sortedIndex(list, value, [iterator])</code><br>Uses a binary search to determine the index at which the value should be inserted into the list in order to maintain the list's sorted order. If an iterator is passed, it will be used to compute the sort ranking of each value.<br></p><pre>_.sortedIndex([10, 20, 30, 40, 50], 35);<br>=&gt; 3</pre><p></p><p id="shuffle"><b class="header">shuffle</b> <code>_.shuffle(list)</code><br>Returns a shuffled copy of the list, using a version of the Fisher-Yates shuffle.<br></p><pre>_.shuffle([1, 2, 3, 4, 5, 6]);<br>=&gt; [4, 1, 6, 3, 5, 2]</pre><p></p><p id="toArray"><b class="header">toArray</b> <code>_.toArray(list)</code><br>Converts the list (anything that can be iterated over), into a real Array. Useful for transmuting the arguments object.<br></p><pre>_.toArray({a:10,b:20});<br>=&gt; [10, 20]</pre><p></p><p id="size"><b class="header">size</b> <code>_.size(list)</code><br>Return the number of values in the list.<br></p><pre>_.size({one : 1, two : 2, three : 3});<br>=&gt; 3</pre><p></p>
		<h2 id="Arrays">Array Functions</h2>
		<p id="first"><b class="header">first</b> <code>_.first(array, [n])</code><br>Returns the first element of an array. Passing n will return the first n elements of the array.<br></p><pre>_.first([5, 4, 3, 2, 1]);<br>=&gt; 5</pre><p></p><p id="initial"><b class="header">initial</b> <code>_.initial(array, [n])</code><br>Returns everything but the last entry of the array. Especially useful on the arguments object. Pass n to exclude the last n elements from the result. Note: CF arrays start at an index of 1<br></p><pre>_.initial([5, 4, 3, 2, 1]);<br>=&gt; [5, 4, 3, 2]</pre><p></p><p id="last"><b class="header">last</b> <code>_.last(array, [n])</code><br>Returns the last element of an array. Passing n will return the last n elements of the array.<br></p><pre>_.last([5, 4, 3, 2, 1]);<br>=&gt; 1</pre><p></p><p id="rest"><b class="header">rest</b> <code>_.rest(array, [index])</code><br>Returns the rest of the elements in an array. Pass an index to return the values of the array from that index onward.<br></p><pre>_.rest([5, 4, 3, 2, 1]);<br>=&gt; [4, 3, 2, 1]</pre><p></p><p id="compact"><b class="header">compact</b> <code>_.compact(array)</code><br>Returns a copy of the array with all falsy values removed. In Coldfusion, false, 0, and "" are all falsy.<br></p><pre>_.compact([0, 1, false, 2, '', 3]);<br>=&gt; [1, 2, 3]</pre><p></p><p id="flatten"><b class="header">flatten</b> <code>_.flatten(array, [shallow])</code><br>Flattens a nested array (the nesting can be to any depth). If you pass shallow, the array will only be flattened a single level.<br></p><pre>_.flatten([1, [2], [3, [[4]]]]);<br>=&gt; [1, 2, 3, 4];<br><br>_.flatten([1, [2], [3, [[4]]]], true);<br>=&gt; [1, 2, 3, [[4]]];</pre><p></p><p id="without"><b class="header">without</b> <code>_.without(array, [*values])</code><br>Returns a copy of the array with all instances of the values removed.<br></p><pre>_.without([1, 2, 1, 0, 3, 1, 4], 0, 1);<br>=&gt; [2, 3, 4]</pre><p></p><p id="union"><b class="header">union</b> <code>_.union(*arrays)</code><br>Computes the union of the passed-in arrays: the list of unique items, in order, that are present in one or more of the arrays.<br></p><pre>_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br>=&gt; [1, 2, 3, 101, 10]</pre><p></p><p id="intersection"><b class="header">intersection</b> <code>_.intersection(*arrays)</code><br>Computes the list of values that are the intersection of all the arrays. Each value in the result is present in each of the arrays.<br></p><pre>_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br>=&gt; [1, 2]</pre><p></p><p id="difference"><b class="header">difference</b> <code>_.difference(array, *others)</code><br>Similar to without, but returns the values from array that are not present in the other arrays.<br></p><pre>_.difference([1, 2, 3, 4, 5], [5, 2, 10]);<br>=&gt; [1, 3, 4]</pre><p></p><p id="uniq"><b class="header">uniq</b> <code>_.uniq(array, [isSorted], [iterator])</code><br>Produces a duplicate-free version of the array. If you know in advance that the array is sorted, passing true for isSorted will run a much faster algorithm. If you want to compute unique items based on a transformation, pass an iterator function.<br></p><pre>_.uniq([1, 2, 1, 3, 1, 4]);<br>=&gt; [1, 2, 3, 4]</pre><p></p><p id="zip"><b class="header">zip</b> <code>_.zip(*arrays)</code><br>Merges together the values of each of the arrays with the values at the corresponding position. Useful when you have separate data sources that are coordinated through matching array indexes. If you're working with a matrix of nested arrays, zip.apply can transpose the matrix in a similar fashion.<br></p><pre>_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);<br>=&gt; [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]</pre><p></p><p id="indexOf"><b class="header">indexOf</b> <code>_.indexOf(array, value, [isSorted])</code><br>Returns the index at which value can be found in the array, or -1 if value is not present in the array. Uses the native ArrayFind() function. If you're working with a large array, and you know that the array is already sorted, pass true for isSorted to use a faster binary search.<br></p><pre>_.indexOf([1, 2, 3], 2);<br>=&gt; 1</pre><p></p><p id="lastIndexOf"><b class="header">lastIndexOf</b> <code>_.lastIndexOf(array, value)</code><br>Returns the index of the last occurrence of value in the array, or -1 if value is not present.<br></p><pre>_.lastIndexOf([1, 2, 3, 1, 2, 3], 2);<br>=&gt; 4</pre><p></p><p id="range"><b class="header">range</b> <code>_.range([start], stop, [step])</code><br>A function to create flexibly-numbered lists of integers, handy for each and map loops. start, if omitted, defaults to 0; step defaults to 1. Returns a list of integers from start to stop, incremented (or decremented) by step, exclusive.<br></p><pre>_.range(10);<br>=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>_.range(1, 11);<br>=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>_.range(0, 30, 5);<br>=&gt; [0, 5, 10, 15, 20, 25]<br>_.range(0, -10, -1);<br>=&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]<br>_.range(0);<br>=&gt; []</pre><p></p>
		<h2 id="Objects">Object Functions</h2>
		<p id="keys"><b class="header">keys</b> <code>_.keys(object)</code><br>Retrieve all the names of the object's properties.<br></p><pre>_.keys({one : 1, two : 2, three : 3});<br>=&gt; ["one", "two", "three"]</pre><p></p><p id="values"><b class="header">values</b> <code>_.values(object)</code><br>Returns true if any of the values in the list pass the iterator truth test. Short-circuits and stops traversing the list if a true element is found.<br></p><pre>_.values({one : 1, two : 2, three : 3});<br>=&gt; [1, 2, 3]</pre><p></p><p id="functions"><b class="header">functions</b> <code>_.functions(object)</code><br>Returns a sorted list of the names of every method in an object â€” that is to say, the name of every function property of the object.<br></p><pre>_.functions(_);<br>=&gt; ["all", "any", "bind", "bindAll", "clone", "compact", "compose" ...</pre><p></p><p id="extend"><b class="header">extend</b> <code>_.extend(destination, *sources)</code><br>Copy all of the properties in the source objects over to the destination object, and return the destination object. It's in-order, so the last source will override properties of the same name in previous arguments.<br></p><pre>_.extend({name : 'moe'}, {age : 50});<br>=&gt; {name : 'moe', age : 50}</pre><p></p><p id="pick"><b class="header">pick</b> <code>_.pick(object, *keys)</code><br>Return a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys).<br></p><pre>_.pick({name : 'moe', age: 50, userid : 'moe1'}, 'name', 'age');<br>=&gt; {name : 'moe', age : 50}</pre><p></p><p id="defaults"><b class="header">defaults</b> <code>_.defaults(object, *defaults)</code><br>Fill in missing properties in object with default values from the defaults objects, and return the object. As soon as the property is filled, further defaults will have no effect.<br></p><pre>iceCream = {flavor : "chocolate"};<br>_.defaults(iceCream, {flavor : "vanilla", sprinkles : "lots"});<br>=&gt; {flavor : "chocolate", sprinkles : "lots"}</pre><p></p><p id="clone"><b class="header">clone</b> <code>_.clone(object)</code><br>Create a shallow-copied clone of the object. Any nested objects or arrays will be copied by reference, not duplicated.<br></p><pre>_.clone({name : 'moe'});<br>=&gt; {name : 'moe'};</pre><p></p><p id="has"><b class="header">has</b> <code>_.has(object, key)</code><br>Does the object contain the given key?<br></p><pre>_.has({a: 1, b: 2, c: 3}, "b");<br>=&gt; true</pre><p></p><p id="isEmpty"><b class="header">isEmpty</b> <code>_.isEmpty(object)</code><br>Returns true if object contains no values. Delegates to structIsEmpty()<br></p><pre>_.isEmpty([1, 2, 3]);<br>=&gt; false<br>_.isEmpty({});<br>=&gt; true</pre><p></p><p id="isArray"><b class="header">isArray</b> <code>_.isArray(object)</code><br>Returns true if object is an Array. Delegates to native isArray();<br></p><pre>_.isArray({one: 1});<br>=&gt; false<br>_.isArray([1,2,3]);<br>=&gt; true</pre><p></p><p id="isObject"><b class="header">isObject</b> <code>_.isObject(object)</code><br>Returns true if value is an Object. Delegates to native isObject()<br></p><pre>_.isObject({});<br>=&gt; true <br>_.isObject(1);<br>=&gt; false</pre><p></p><p id="isFunction"><b class="header">isFunction</b> <code>_.isFunction(object)</code><br>Returns true if object is a Function.	Delegates to native isClosure()<br></p><pre>_.isFunction(function(){return 1;});<br>=&gt; true</pre><p></p><p id="isString"><b class="header">isString</b> <code>_.isString(object)</code><br>Returns true if object is a String.<br></p><pre>_.isString("moe");<br>=&gt; true</pre><p></p><p id="isNumber"><b class="header">isNumber</b> <code>_.isNumber(object)</code><br>Returns true if object is a number. Delegates to native isNumeric()<br></p><pre>_.isNumber(8.4 + 5);<br>=&gt; true</pre><p></p><p id="isBoolean"><b class="header">isBoolean</b> <code>_.isBoolean(object)</code><br>Returns true if object is a boolean. Delegates to native isBoolean()<br></p><pre>_.isBoolean(false);<br>=&gt; true</pre><p></p><p id="isDate"><b class="header">isDate</b> <code>_.isDate(object)</code><br>Returns true if object is a date. Delegates to native isDate()<br></p><pre>_,isDate(now());<br>=&gt; true</pre><p></p><p id="isNaN"><b class="header">isNaN</b> <code>_.isNaN(object)</code><br>Returns true if object is not a number. Delegates to native isNumeric()<br></p><pre>_.isNaN("string");<br>=&gt; true</pre><p></p>
		<h2 id="Functions">Function (uh, ahem) Functions</h2>
		<p id="bind"><b class="header">bind</b> <code>_.bind(function, object, arguments)</code><br>Bind a function to a structure, meaning that whenever the function is called, the value of "this" will be the structure. Optionally, bind arguments to the function to pre-fill them, also known as partial application.<br></p><pre>func = function(greeting){ return greeting + ': ' + this.name };<br>func = _.bind(func, {name : 'moe'}, {greeting: 'hi'});<br>func();<br>=&gt; 'hi: moe'</pre><p></p><p id="bindAll"><b class="header">bindAll</b> <code>_.bindAll(object, [*methodNames])</code><br>Bind all of an object's methods to that object. Useful for ensuring that all callbacks defined on an object belong to it.<br></p><pre>buttonView = {label: 'button', onClick : function(){ return 'clicked: ' &amp; this.label; }}<br>_.bindAll(buttonView);<br>_.bindAll(buttonView);<br>=&gt; 'clicked: button'</pre><p></p><p id="memoize"><b class="header">memoize</b> <code>_.memoize(function, [hashFunction])</code><br>Memoizes a given function by caching the computed result. Useful for speeding up slow-running computations. If passed an optional hashFunction, it will be used to compute the hash key for storing the result, based on the arguments to the original function. The default hashFunction just uses the first argument to the memoized function as the key.<br></p><pre>fibonacci = _.memoize(function(n) {  return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2); });</pre><p></p><p id="delay"><b class="header">delay</b> <code>_.delay(function, wait, arguments)</code><br>Delays a function for the given number of milliseconds, and then calls it with the arguments supplied in the args struct.<br></p><pre>_.delay(function (msg) {return msg;}, 1000, {msg = "hi"});<br>=&gt; "hi" // appears after one second</pre><p></p><p id="once"><b class="header">once</b> <code>_.once(function)</code><br>Returns a function that will be executed at most one time, no matter how often you call it. Useful for lazy initialization.<br></p><pre>_.once(function () { return "should only see this once"; });<br>once();<br>=&gt; "should only see this once"<br>once();<br>=&gt; // nothing</pre><p></p><p id="after"><b class="header">after</b> <code>_.after(count, function)</code><br>Returns a function that will only be executed after being called N times.<br></p><pre>notes = ["one","two"];<br>render = function () {<br>return "render should only happen once";<br>};<br>renderNotes = _.after(arrayLen(notes), render);<br>_.each(notes, function(note) {<br>renderNotes();<br>});<br>=&gt; 'render should only happen once'</pre><p></p><p id="wrap"><b class="header">wrap</b> <code>_.wrap(function, wrapper)</code><br>Returns the first function passed as an argument to the second, allowing you to adjust arguments, run code before and after, and conditionally execute the original function.<br></p><pre>hello = function(name) { return "hello: " + name; };<br>hello = _.wrap(hello, function(func) {<br>return "before, " + func("moe") + ", after";<br>});<br>hello();<br>=&gt; 'before, hello: moe, after'</pre><p></p>
		<h2 id="Utilities">Utility Functions</h2>
		<p id="times"><b class="header">times</b> <code>_.times(n, iterator)</code><br>Invokes the given iterator function n times.<br></p><pre>_.times(3, function(){ genie.grantWish(); });</pre><p></p><p id="mixin"><b class="header">mixin</b> <code>_.mixin(object)</code><br>Allows you to extend Underscore with your own utility functions. Pass a struct of {name: function} definitions to have your functions added to the Underscore object, <s>as well as the OOP wrapper.</s><br></p><pre>_.mixin({ <br>upper: function(string) { return uCase(string); }<br>});<br>_.upper("fabio");<br>=&gt; "Fabio"</pre><p></p><p id="result"><b class="header">result</b> <code>_.result(object, property)</code><br>If the value of the named property is a function then invoke it; otherwise, return it.<br></p><pre>object = {cheese: 'crumpets', stuff: function(){ return 'nonsense'; }};<br>_.result(object, 'cheese');<br>=&gt; "crumpets"<br>_.result(object, 'stuff');<br>=&gt; "nonsense"</pre><p></p>
	</div>

</body><style type="text/css">embed[type*="application/x-shockwave-flash"],embed[src*=".swf"],object[type*="application/x-shockwave-flash"],object[codetype*="application/x-shockwave-flash"],object[src*=".swf"],object[codebase*="swflash.cab"],object[classid*="D27CDB6E-AE6D-11cf-96B8-444553540000"],object[classid*="d27cdb6e-ae6d-11cf-96b8-444553540000"],object[classid*="D27CDB6E-AE6D-11cf-96B8-444553540000"]{	display: none !important;}</style></html>